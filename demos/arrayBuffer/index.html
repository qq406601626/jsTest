<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    // arrayBuffer实例代表一块内存。不可以直接操作（因为不允许直接操作内存），可以通过视图进行操作。
    // 试图包括TypedArray和DataView，区别是TypedArray每个元素的类型都一样，DataView可以包含不同类型的元素
    // ArrayBuffer、TypedArray、DataView都是二进制数组，二进制数组并不是真正的数组，而是类似数组的对象。
    // 因为字节和进制是等价的,所以可以把TypedArray理解为进制.
    // 则关键在于，ASCII码目的在于，使用1个字节的大小对字符进行编码，因而存在一个字符与一个整型数的唯一映射（在ASCII编码中，由于最高位用作校验位，因而其范围表示在0-127，可表示128个字符）。
    // 选择十六进制，是因为8位二进制的数字可以方便的转换为2个十六进制的数字。一个字节能且只能由一对十六进制来表示，比如10110110可以表示为B6。如果使用4进制的话则需要使用4个数字来表示一个字节，不够简洁；使用8进制的话，最靠左的8进制数是由2位二进制数字来表示的，相比于使用16进制有些美中不足。
    // 二进制'10110110'转化位16进制位b2:parseInt('10110110',2).toString(16).因为parseInt('1011',2).toString(16)为b,parseInt('0110',2).toString(16)为2.
    // 总结就是：8进制总共有Math.pow(2,8) = 256种可能，一个16进制可以代表16种可能性，16*16 =256，所以一个8进制可以由两个16进制数字代替。
    const memory = new ArrayBuffer(32) // 32代表这块内存有32个字节。一个字节就是一个文字。默认为8进制,即8*32位.一个文字在不同的进制下占用不同的位。Int8Array表示8位，Int16Array表示16位。
    // memory.byteLength // arrayBuffer实例的byteLength表示内存的字节长度,而非位数.
    // 创建一个TypedArray视图实例并指定内存块。Int8Array代表每个元素为8位.
    // new Int8Array(memory) 表示这个数组有32个字节即32个元素,每个元素都是8位,即这个数组总共有32*8位.
    // const int8 = new Int8Array(memory)
    // const int8_2 = new Int8Array([1,2,3,4,5]) // 创建视图实例时，也可以传入一个普通数组，表示直接分配内存生成底层的ArrayBuffer实例，并同时完成对这段内存的赋值。传入的数组为五个元素,所以length为5.每个元素为1个字节,所以byteLength为5*1.
    // const i32 = new Int32Array(['a','b','c','d','e']) // 传入的数组为五个元素,所以length为5.每个元素为4个字节,所以byteLength为5*4.
    // const f64a = new Float64Array(8); // 生成一个 8 个成员的Float64Array数组（共 64 字节）.视图还可以不通过ArrayBuffer对象，直接分配内存而生成。
    // const typedArray = new Int16Array(new Uint32Array(4)); // TypedArray 数组的构造函数，可以接受另一个TypedArray实例作为参数。此时是把TypedArray当作数组传入,即参数为四个元素的数组.
    // 注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。
    // 总结:当传入的为参数为arrayBuffer时,参数为字节.当传入的为普通数组时,参数为元素.当传入的为数字时,参数为元素数量.
    // const copyMemory = memory.slice(0,4) // ArrayBuffer实例的slice方法可以复制内存。单位为字节。
    // const int8 = new Int8Array(memory) // byteLength为32,length为32*8/8 = 32.可以理解为int8为8进制,每个8进制元素占一个字节,所以结果为32
    // const int16 = new Int16Array(memory) // byteLength为32,length为32*8/16 = 16.可以理解为int16为16进制,每个16进制元素占两个字节,所以结果为16
    // const int32 = new It32Array(memory) // byteLength为32,length为32*8/32 = 8.可以理解为int32为32进制,每个32进制元素占四个字节,所以结果为8

    // const int8 = new Int32Array(memory,2,2) // 创建TypedArray实例并传入ArrayBuffer,然后指定开始[字节]序号(默认为0)和包含的数据个数(默认直到本段内存区域结束)

    // const buffer = new ArrayBuffer(8);
    // const i16 = new Int16Array(buffer, 1); // 报错.新生成一个 8 个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错。因为，带符号的 16 位整数需要两个字节，所以byteOffset参数必须能够被 2 整除。
</script>
</html>
