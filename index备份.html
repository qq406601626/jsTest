<!DOCTYPE html>
<html lang="ch">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/lodash.min.js"></script>
    <script src="js/moment.js"></script>
    <script src="js/moment-duration-format.js"></script>
    <script src="js/dayjs.min.js"></script>
    <script src="js/echarts.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
<canvas id="cvs"></canvas>
</body>

<script>
    const rafTimeout = (fn, delay = 0, interval = false) => {
        let start = null
        const timeElapse = (timestamp) => {
            if (!start) {
                start = timestamp
            }
            const elapsed = timestamp - start
            if (elapsed >= delay) {
                fn()
                if (interval) {
                    start = null
                    raf.id = window.requestAnimationFrame(timeElapse)
                }
            } else {
                raf.id = window.requestAnimationFrame(timeElapse)
            }
        }

        const raf = {
            id: window.requestAnimationFrame(timeElapse)
        }
        return raf
    }

    const cancelRaf = (raf) => {
        if (raf && raf.id) {
            window.cancelAnimationFrame(raf.id)
        }
    }

    // 1.每个文字都是一个单位
    // 2.鼠标移动更改鼠标位置，每个单位体分别延迟一定时间移动
    // 3.单位体的结束位置的y坐标一致，x坐标分别往后错位
    // 4.每次渲染，都从当前位置向鼠标位置移动

    const cvs = document.getElementById('cvs')
    cvs.width = 300
    cvs.height = 300
    const ctx = cvs.getContext('2d')

    class Stage {
        constructor() {
            this.cvs = document.getElementById('cvs')
            this.ctx = this.cvs.getContext('2d')
            this.w = 300
            this.h = 300
            this.mouseTrack = [{x: 10, y: 10}, {x: 20, y: 20}, {x: 30, y: 30}, {x: 40, y: 40}, {x: 50, y: 50},]
            this.stoper = null
            this.wordList = ['h', 'e', 'l', 'l', 'o']
            // this.wordList = [
            //     {
            //         label:'h',
            //         list:[]
            //     },
            //     {
            //         label:'e',
            //         list:[]
            //     },
            //     {
            //         label:'l',
            //         list:[]
            //     },
            //     {
            //         label:'l',
            //         list:[]
            //     },
            //     {
            //         label:'o',
            //         list:[]
            //     },
            // ]
            this.initSize()
            this.on()
        }

        initSize() {
            this.cvs.width = this.w
            this.cvs.height = this.h
        }

        clearStage() {
            this.ctx.clearRect(0, 0, this.w, this.h)
        }

        drawText() {
            if (this.mouseTrack.length) {
                const position = this.mouseTrack.length > 1 ? this.mouseTrack.shift() : this.mouseTrack[0]
                this.wordList.forEach((label, index) => {
                    setTimeout(() => {
                        if (index === 0) {
                            this.clearStage()
                        }
                        this.ctx.fillText(label, position.x + 12 * index, position.y)

                    }, 100 * index)
                })
            }
        }

        on() {
            this.cvs.addEventListener('mousemove', e => {
                this.mouseTrack.push({
                    x: e.x,
                    y: e.y
                })
            })
        }

        render() {
            this.drawText()
            this.stoper = window.requestAnimationFrame(() => {
                this.render()
            })
        }
    }

    const stage = new Stage()
    stage.render()


</script>
</html>
